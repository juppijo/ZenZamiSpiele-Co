<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zami's Variables Farb-Puzzle (Konstant 25 Teile)</title>
    <style>
        /* Allgemeine Impressionistische Basis (Unver√§ndert) */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #a8c0ff 0%, #3f2b96 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px 20px;
        }

        .header {
            color: white;
            text-align: center;
            margin-bottom: 25px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5); 
        }

        .header h1 {
            font-size: 2.8em;
            margin-bottom: 8px;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
            align-items: flex-start; 
            flex-wrap: wrap; 
            justify-content: center;
        }

        .difficulty-selection {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 15px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .difficulty-selection label {
            margin: 0 5px;
            font-weight: 700;
            cursor: pointer;
            transition: color 0.2s;
        }

        .difficulty-selection label:hover {
            color: #ffe81d;
        }

        button {
            padding: 14px 28px;
            font-size: 18px;
            font-weight: 700;
            border: none;
            border-radius: 12px; 
            cursor: pointer;
            background: #ffffff;
            color: #3f2b96;
            box-shadow: 0 6px 15px rgba(0,0,0,0.2); 
            transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s;
        }

        button:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            background: #e9ecef;
        }

        button:active {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        #correct-count {
            align-self: center; 
            font-size: 1.2em; 
            font-weight: bold; 
            color: white; 
            text-shadow: 1px 1px 2px #3f2b96; 
            padding: 5px 15px; 
            border-radius: 12px;
            background: rgba(255, 55, 255, 0.3); 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            min-width: 130px; 
            text-align: center;
        }

        .game-container {
            background: rgba(255,205,255,0.9); 
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 12px 40px rgba(0,0,0,0.4);
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
            flex-direction: row; 
        }

        /* Raster (Desktop-Gr√∂√üe) */
        .grid-container {
            display: grid;
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: var(--gap-size); 
            background: #e0e7e9;
            padding: var(--gap-size);
            border-radius: 12px;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.1);
        }

        .grid-cell {
            background: #fdfdfd;
            border: 2px dashed #aeb8c3;
            border-radius: 6px;
            position: relative;
            transition: background 0.2s;
            width: var(--cell-size); 
            height: var(--cell-size);
        }

        .grid-cell:hover {
            background: #f0f4f7;
        }

        .grid-cell.filled {
            border: 2px solid #5aa95c; 
        }
        
        /* Teile-Bereich (Desktop-Layout) */
        .pieces-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .pieces-area {
            display: grid;
            grid-template-columns: repeat(3, var(--piece-size)); 
            gap: 10px;
            max-height: 650px; 
            overflow-y: auto;
            padding: 15px;
            background: #f7f9fb;
            border-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
        }

        .pieces-area::-webkit-scrollbar {
            width: 8px;
        }

        .pieces-area::-webkit-scrollbar-thumb {
            background-color: #a8c0ff;
            border-radius: 4px;
        }

        /* Einzelne Puzzleteile (Desktop-Gr√∂√üen) */
        .puzzle-piece {
            width: var(--piece-size);
            height: var(--piece-size);
            background: white;
            border: 4px solid #3f2b96; 
            border-radius: 8px;
            cursor: move;
            position: relative;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .puzzle-piece:hover {
            transform: scale(1.05); 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .puzzle-piece.dragging {
            opacity: 0.6;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            border: 4px dashed #3f2b96;
        }
        
        .puzzle-piece.placed {
            width: var(--cell-size-placed); 
            height: var(--cell-size-placed);
            border: 4px solid #3f2b96;
            cursor: pointer;
        }

         .puzzle-piece.invalid {
            border: 4px solid #e74c3c; 
            background: #fdeaea;
        }


        /* Dots (Desktop-Gr√∂√üe) */
        .dot {
            width: var(--dot-size); 
            height: var(--dot-size);
            border-radius: 50%;
            position: absolute;
            border: 2px solid rgba(0,0,0,0.4);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        /* Farb-Definitionen - HIER WURDE !important HINZUGEF√úGT */
        .dot.red { background: #e74c3c !important; } 
        .dot.blue { background: #3498db !important; }
        .dot.yellow { background: #f1c40f !important; }
        .dot.green { background: #2ecc71 !important; }

        /* Dot-Positionen (Variabel) */
        .dot.top-1 { top: 5%; left: 25%; } 
        .dot.top-2 { top: 5%; right: 25%; } 
        .dot.right-1 { right: 5%; top: 25%; } 
        .dot.right-2 { right: 5%; bottom: 25%; } 
        .dot.bottom-1 { bottom: 5%; left: 25%; } 
        .dot.bottom-2 { bottom: 5%; right: 25%; } 
        .dot.left-1 { left: 5%; top: 25%; } 
        .dot.left-2 { left: 5%; bottom: 25%; } 

        /* Win Message und Overlay CSS (Unver√§ndert) */
        .win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ffffff;
            padding: 50px 70px;
            border-radius: 20px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.5);
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .win-message.show {
            display: block;
            animation: popIn 0.5s ease-out;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .win-message h2 {
            color: #2ecc71;
            font-size: 3.5em;
            margin-bottom: 25px;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            z-index: 999;
        }

        .overlay.show {
            display: block;
        }

        /* ------------------------------------------------------------------ */
        /* MEDIA QUERY F√úR SMARTPHONE-FORMAT (unter 650px Breite) (Unver√§ndert) */
        /* ------------------------------------------------------------------ */
        @media (max-width: 650px) {
            
            /* Gr√∂√üere Anpassung f√ºr Mobile */
            :root {
                --cell-size: 60px !important;
                --cell-size-placed: 58px !important;
                --piece-size: 58px !important;
                --gap-size: 4px !important;
                --dot-size: 16px !important;
            }

            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                flex-direction: column; 
                gap: 10px;
                align-items: center;
            }

            .difficulty-selection {
                padding: 5px 10px;
            }
            
            #correct-count {
                font-size: 1em;
                padding: 5px 10px;
            }

            .game-container {
                flex-direction: column; 
                padding: 15px;
                gap: 20px;
                width: 100%;
                max-width: 400px; 
            }

            /* Pieces-Area (Mobile-Layout): Immer 4 Spalten auf Mobile */
            .pieces-area {
                gap: 4px;
                padding: 10px;
                max-height: 250px; 
                grid-template-columns: repeat(4, var(--piece-size)); 
            }
            
            /* Dots (Mobile-Gr√∂√üe) */
            .dot {
                border: 1px solid rgba(0,0,0,0.4); 
            }

            /* Dot-Positionen (Mobile) */
            .dot.top-1 { top: 2%; left: 20%; } 
            .dot.top-2 { top: 2%; right: 20%; } 
            .dot.right-1 { right: 2%; top: 20%; } 
            .dot.right-2 { right: 2%; bottom: 20%; } 
            .dot.bottom-1 { bottom: 2%; left: 20%; } 
            .dot.bottom-2 { bottom: 2%; right: 20%; } 
            .dot.left-1 { left: 2%; top: 20%; } 
            .dot.left-2 { left: 2%; bottom: 20%; } 
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé® Jo's Variables Farb-Puzzle</h1>
        <p>Ziehe die Teile ins Raster (oder verschiebe sie) und drehe sie durch Klick. Alle Kanten **m√ºssen** farblich passen!</p>
    </div>

    <div class="controls">
        <div class="difficulty-selection">
            <strong>Schwierigkeit:</strong>
            <div>
                <input type="radio" id="size2" name="gridSize" value="2" onchange="changeGridSize(2)" checked>
                <label for="size2">2x2</label>
                <input type="radio" id="size3" name="gridSize" value="3" onchange="changeGridSize(3)">
                <label for="size3">3x3</label>
                <input type="radio" id="size4" name="gridSize" value="4" onchange="changeGridSize(4)">
                <label for="size4">4x4</label>
                <input type="radio" id="size5" name="gridSize" value="5" onchange="changeGridSize(5)">
                <label for="size5">5x5</label>
            </div>
        </div>

        <button onclick="resetGame()">‚ú® Neu starten</button>
        <div id="correct-count">Richtig: 0 / 4</div>
    </div>

    <div class="game-container">
        <div class="grid-container" id="grid"></div>
        <div class="pieces-container">
            <h3 style="text-align: center; color: #3f2b96;">Verf√ºgbare Teile (25)</h3>
            <div class="pieces-area" id="pieces"></div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>
    <div class="win-message" id="winMessage">
        <h2>üéâ Gewonnen! üéâ</h2>
        <p style="font-size: 1.3em; margin-bottom: 25px;">Die Farben tanzen perfekt!</p>
        <button onclick="resetGame()">Nochmal spielen</button>
    </div>

    <script>
        const colors = ['red', 'blue', 'yellow', 'green'];
        
        /**
         * üé® Die 24 eindeutigen Puzzlemuster (4!) nach dem Schema [A, B, C, B, D, A, C, D]
         * Dabei sind A, B, C, D vier verschiedene Farben (Permutationen von 0, 1, 2, 3).
         *
         * Farbcode:
         * 0 = Rot
         * 1 = Blau
         * 2 = Gelb
         * 3 = Gr√ºn

        const allPatterns = [
            // A=0 (Rot)
            [0, 1, 2, 1, 3, 0, 2, 3], // (A,B,C,D) = (0,1,2,3)
            [0, 1, 3, 1, 2, 0, 3, 2], // (A,B,C,D) = (0,1,3,2)
            [0, 2, 1, 2, 3, 0, 1, 3], // (A,B,C,D) = (0,2,1,3)
            [0, 2, 3, 2, 1, 0, 3, 1], // (A,B,C,D) = (0,2,3,1)
            [0, 3, 1, 3, 2, 0, 1, 2], // (A,B,C,D) = (0,3,1,2)
            [0, 3, 2, 3, 1, 0, 2, 1], // (A,B,C,D) = (0,3,2,1)

            // A=1 (Blau)
            [1, 0, 2, 0, 3, 1, 2, 3], // (A,B,C,D) = (1,0,2,3)
            [1, 0, 3, 0, 2, 1, 3, 2], // (A,B,C,D) = (1,0,3,2)
            [1, 2, 0, 2, 3, 1, 0, 3], // (A,B,C,D) = (1,2,0,3)
            [1, 2, 3, 2, 0, 1, 3, 0], // (A,B,C,D) = (1,2,3,0)
            [1, 3, 0, 3, 2, 1, 0, 2], // (A,B,C,D) = (1,3,0,2)
            [1, 3, 2, 3, 0, 1, 2, 0], // (A,B,C,D) = (1,3,2,0)

            // A=2 (Gelb)
            [2, 0, 1, 0, 3, 2, 1, 3], // (A,B,C,D) = (2,0,1,3)
            [2, 0, 3, 0, 1, 2, 3, 1], // (A,B,C,D) = (2,0,3,1)
            [2, 1, 0, 1, 3, 2, 0, 3], // (A,B,C,D) = (2,1,0,3)
            [2, 1, 3, 1, 0, 2, 3, 0], // (A,B,C,D) = (2,1,3,0)
            [2, 3, 0, 3, 1, 2, 0, 1], // (A,B,C,D) = (2,3,0,1)
            [2, 3, 1, 3, 0, 2, 1, 0], // (A,B,C,D) = (2,3,1,0)

            // A=3 (Gr√ºn)
            [3, 0, 1, 0, 2, 3, 1, 2], // (A,B,C,D) = (3,0,1,2)
            [3, 0, 2, 0, 1, 3, 2, 1], // (A,B,C,D) = (3,0,2,1)
            [3, 1, 0, 1, 2, 3, 0, 2], // (A,B,C,D) = (3,1,0,2)
            [3, 1, 2, 1, 0, 3, 2, 0], // (A,B,C,D) = (3,1,2,0)
            [3, 2, 0, 2, 1, 3, 0, 1], // (A,B,C,D) = (3,2,0,1)
            [3, 2, 1, 2, 0, 3, 1, 0],  // (A,B,C,D) = (3,2,1,0)

            // Die 25 Muster (1 Duplikat inkludiert)
            [0, 1, 2, 1, 3, 0, 2, 3] // (A,B,C,D) = (0,1,2,3)
        ];
        */
        /**
         * All 25 unique piece patterns for the 5x5-Grid Puzzle.
         * This set consists of all 24 permutations of the four colors (0, 1, 2, 3),
         * with the first pattern [0, 0, 1, 1, 2, 2, 3, 3] duplicated to reach 25 pieces.
         * * Schema: [T1, T2, R1, R2, B1, B2, L1, L2]
         * Where: T1=T2=A, R1=R2=B, B1=B2=C, L1=L2=D
         * And: A, B, C, D are a unique permutation of [0, 1, 2, 3] for patterns 0-23.
         * * Color Mapping:
         * 0 = Red
         * 1 = Blue
         * 2 = Yellow
         * 3 = Green
         */
        const allPatterns = [
            // --- 24 Unique Permutations (4!) ---

            // A=0 (Red)
            [0, 0, 1, 1, 2, 2, 3, 3], // 0: A=0, B=1, C=2, D=3
            [0, 0, 1, 1, 3, 3, 2, 2], // 1: A=0, B=1, C=3, D=2
            [0, 0, 2, 2, 1, 1, 3, 3], // 2: A=0, B=2, C=1, D=3
            [0, 0, 2, 2, 3, 3, 1, 1], // 3: A=0, B=2, C=3, D=1
            [0, 0, 3, 3, 1, 1, 2, 2], // 4: A=0, B=3, C=1, D=2
            [0, 0, 3, 3, 2, 2, 1, 1], // 5: A=0, B=3, C=2, D=1

            // A=1 (Blue)
            [1, 1, 0, 0, 2, 2, 3, 3], // 6: A=1, B=0, C=2, D=3
            [1, 1, 0, 0, 3, 3, 2, 2], // 7: A=1, B=0, C=3, D=2
            [1, 1, 2, 2, 0, 0, 3, 3], // 8: A=1, B=2, C=0, D=3
            [1, 1, 2, 2, 3, 3, 0, 0], // 9: A=1, B=2, C=3, D=0
            [1, 1, 3, 3, 0, 0, 2, 2], // 10: A=1, B=3, C=0, D=2
            [1, 1, 3, 3, 2, 2, 0, 0], // 11: A=1, B=3, C=2, D=0

            // A=2 (Yellow)
            [2, 2, 0, 0, 1, 1, 3, 3], // 12: A=2, B=0, C=1, D=3
            [2, 2, 0, 0, 3, 3, 1, 1], // 13: A=2, B=0, C=3, D=1
            [2, 2, 1, 1, 0, 0, 3, 3], // 14: A=2, B=1, C=0, D=3
            [2, 2, 1, 1, 3, 3, 0, 0], // 15: A=2, B=1, C=3, D=0
            [2, 2, 3, 3, 0, 0, 1, 1], // 16: A=2, B=3, C=0, D=1
            [2, 2, 3, 3, 1, 1, 0, 0], // 17: A=2, B=3, C=1, D=0

            // A=3 (Green)
            [3, 3, 0, 0, 1, 1, 2, 2], // 18: A=3, B=0, C=1, D=2
            [3, 3, 0, 0, 2, 2, 1, 1], // 19: A=3, B=0, C=2, D=1
            [3, 3, 1, 1, 0, 0, 2, 2], // 20: A=3, B=1, C=0, D=2
            [3, 3, 1, 1, 2, 2, 0, 0], // 21: A=3, B=1, C=2, D=0
            [3, 3, 2, 2, 0, 0, 1, 1], // 22: A=3, B=2, C=0, D=1
            [3, 3, 2, 2, 1, 1, 0, 0], // 23: A=3, B=2, C=1, D=0

            // --- The 25th Piece (Duplikat von Muster 0) ---
            [0, 0, 1, 1, 2, 2, 3, 3]  // 24: A=0, B=1, C=2, D=3 (Duplikat)
        ];
        
        let pieces = []; 
        let GRID_SIZE = 2; // Startet bei 2x2
        let gridState = Array(GRID_SIZE * GRID_SIZE).fill(null);
        let draggedPiece = null;
        let originalGridIndex = null; 
        
        // --- Hilfsfunktionen f√ºr die Gr√∂√üenanpassung --- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  cellSize = 120; 
        function setCSSVariables() {
            const root = document.documentElement;
            // Desktop-Werte
            const cellSize = 110; 
            const gapSize = 8;
            const pieceSize = 110

            // Setzen der CSS-Variablen
            root.style.setProperty('--grid-size', GRID_SIZE);
            root.style.setProperty('--cell-size', `${cellSize}px`);
            root.style.setProperty('--cell-size-placed', `${cellSize + 2}px`); 
            root.style.setProperty('--piece-size', `${pieceSize}px`);
            root.style.setProperty('--gap-size', `${gapSize}px`);
            root.style.setProperty('--dot-size', `24px`);

            // Spezielles Grid-Template f√ºr das Raster
            document.getElementById('grid').style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${cellSize}px)`;
        }

        // --- Hauptlogik f√ºr Spielstart und -neustart ---
        function changeGridSize(newSize) {
            GRID_SIZE = newSize;
            initGame(false); 
        }

        function getPieceById(id) {
            return pieces.find(p => p.id == id);
        }

        function createPiece(pattern, id) {
            return {
                id: id,
                pattern: pattern,
                rotation: 0,
                placed: false,
                originalIndex: id 
            };
        }

        function initGame(initial = true) {
            if (initial) {
                pieces = allPatterns.map((p, i) => createPiece([...p], i));
            }
            
            setCSSVariables(); 
            
            const requiredCells = GRID_SIZE * GRID_SIZE;
            
            gridState = Array(requiredCells).fill(null);

            pieces.forEach(p => p.placed = false); 
            
            pieces.forEach(p => {
                p.rotation = 0; 
                const numRotations = Math.floor(Math.random() * 4); 
                for (let k = 0; k < numRotations; k++) {
                    rotatePiecePattern(p); 
                }
            });
            
            renderPieces();
            renderGrid();
            updateCorrectCount(); 
        }

        function shufflePieces() {
            for (let i = pieces.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
            }
            
            const requiredCells = GRID_SIZE * GRID_SIZE;
            gridState = Array(requiredCells).fill(null);

            pieces.forEach(p => p.placed = false); 

            pieces.forEach(p => {
                p.rotation = 0; 
                const numRotations = Math.floor(Math.random() * 4); 
                for (let k = 0; k < numRotations; k++) {
                    rotatePiecePattern(p); 
                }
            });
            
            renderPieces();
            renderGrid();
            updateCorrectCount(); 
        }

        function resetGame() {
            document.getElementById('overlay').classList.remove('show');
            document.getElementById('winMessage').classList.remove('show');
            shufflePieces();
        }

        function rotatePiecePattern(piece) {
            const p = piece.pattern;
            piece.pattern = [p[7], p[6], p[0], p[1], p[3], p[2], p[4], p[5]];
        }

        function rotatePiece(piece) {
            rotatePiecePattern(piece);
            piece.rotation = (piece.rotation + 90) % 360;
        }

        function renderPieceElement(piece, isPlaced = false, gridIndex = null) {
            const div = document.createElement('div');
            div.className = 'puzzle-piece' + (isPlaced ? ' placed' : '');
            div.draggable = true; 
            div.dataset.id = piece.id;
            if (isPlaced) {
                 div.dataset.gridIndex = gridIndex; 
            }

            const positions = ['top-1', 'top-2', 'right-1', 'right-2', 'bottom-1', 'bottom-2', 'left-1', 'left-2'];
            piece.pattern.forEach((colorIdx, i) => {
                const dot = document.createElement('div');
                dot.className = `dot ${colors[colorIdx]} ${positions[i]}`;
                div.appendChild(dot);
            });

            // Klick zum Rotieren
            div.addEventListener('click', (e) => {
                e.stopPropagation(); 
                rotatePiece(piece);
                if (isPlaced) {
                    renderGrid(); 
                    updateCorrectCount(); 
                    checkWin();
                } else {
                    renderPieces();
                }
            });

            // Drag-Start-Logik
            div.addEventListener('dragstart', (e) => {
                draggedPiece = piece;
                div.classList.add('dragging');
                if (isPlaced) {
                    originalGridIndex = gridIndex; 
                    e.dataTransfer.setData('text/plain', piece.id); 
                } else {
                    originalGridIndex = null; 
                }
            });

            // Drag-End-Logik
            div.addEventListener('dragend', (e) => {
                div.classList.remove('dragging');
                draggedPiece = null;
                originalGridIndex = null;
            });

            return div;
        }

        function renderPieces() {
            const container = document.getElementById('pieces');
            container.innerHTML = '';
            
            pieces.filter(p => !p.placed).forEach(piece => {
                container.appendChild(renderPieceElement(piece));
            });
        }

        function renderGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            
            const totalCells = GRID_SIZE * GRID_SIZE;

            for (let i = 0; i < totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.index = i;

                cell.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });

                cell.addEventListener('drop', (e) => {
                    e.preventDefault();
                    
                    if (draggedPiece && !gridState[i]) {
                        
                        if (originalGridIndex !== null && originalGridIndex !== i) {
                            gridState[originalGridIndex] = null; 
                        }
                        
                        gridState[i] = draggedPiece;
                        draggedPiece.placed = true;
                        
                        renderPieces();
                        renderGrid();
                        updateCorrectCount(); 
                        checkWin();
                        
                    } else if (draggedPiece && gridState[i] && originalGridIndex === null) {
                         
                         renderGrid(); 
                         renderPieces();
                    }
                    
                    draggedPiece = null;
                    originalGridIndex = null;
                });

                if (gridState[i]) {
                    cell.classList.add('filled');
                    
                    const pieceElement = renderPieceElement(gridState[i], true, i); 
                    
                    if (!checkPieceFits(i)) {
                        pieceElement.classList.add('invalid');
                    }
                    
                    cell.appendChild(pieceElement);
                }

                grid.appendChild(cell);
            }
        }

        document.getElementById('pieces').addEventListener('dragover', (e) => e.preventDefault());
        document.getElementById('pieces').addEventListener('drop', (e) => {
            e.preventDefault();
            if (draggedPiece) {
                
                if (originalGridIndex !== null) {
                    gridState[originalGridIndex] = null; 
                }
                
                draggedPiece.placed = false; 
                
                renderPieces();
                renderGrid(); 
                updateCorrectCount(); 
            }
            draggedPiece = null;
            originalGridIndex = null;
        });


        function checkPieceFits(index) {
            const row = Math.floor(index / GRID_SIZE);
            const col = index % GRID_SIZE;
            const piece = gridState[index];
            if (!piece) return true; 

            // Kanten: 0=oben, 1=rechts, 2=unten, 3=links
            
            // Check top neighbor (row > 0)
            if (row > 0 && gridState[index - GRID_SIZE]) {
                const top = gridState[index - GRID_SIZE];
                const myTop = getEdgeColors(piece, 0);
                const theirBottom = getEdgeColors(top, 2);
                if (myTop[0] !== theirBottom[0] || myTop[1] !== theirBottom[1]) return false;
            }
            
            // Check right neighbor (col < GRID_SIZE - 1)
            if (col < GRID_SIZE - 1 && gridState[index + 1]) {
                const right = gridState[index + 1];
                const myRight = getEdgeColors(piece, 1);
                const theirLeft = getEdgeColors(right, 3);
                if (myRight[0] !== theirLeft[0] || myRight[1] !== theirLeft[1]) return false;
            }

            // Check bottom neighbor (row < GRID_SIZE - 1)
            if (row < GRID_SIZE - 1 && gridState[index + GRID_SIZE]) {
                const bottom = gridState[index + GRID_SIZE];
                const myBottom = getEdgeColors(piece, 2);
                const theirTop = getEdgeColors(bottom, 0);
                if (myBottom[0] !== theirTop[0] || myBottom[1] !== theirTop[1]) return false;
            }

            // Check left neighbor (col > 0)
            if (col > 0 && gridState[index - 1]) {
                const left = gridState[index - 1];
                const myLeft = getEdgeColors(piece, 3);
                const theirRight = getEdgeColors(left, 1);
                if (myLeft[0] !== theirRight[0] || myLeft[1] !== theirRight[1]) return false;
            }

            return true;
        }

        function updateCorrectCount() {
            let correctCount = 0;
            const totalCells = GRID_SIZE * GRID_SIZE;
            for (let i = 0; i < totalCells; i++) {
                if (gridState[i] && checkPieceFits(i)) {
                    correctCount++;
                }
            }
            document.getElementById('correct-count').textContent = `Richtig: ${correctCount} / ${totalCells}`;
            return correctCount; 
        }


        function getEdgeColors(piece, edge) {
            const indices = [
                [0, 1], [2, 3], [4, 5], [6, 7]
            ];
            return indices[edge].map(i => piece.pattern[i]);
        }

        function checkWin() {
            const totalCells = GRID_SIZE * GRID_SIZE;
            if (gridState.length !== totalCells || gridState.some(cell => cell === null)) return false; 
            
            const correctCount = updateCorrectCount(); 

            if (correctCount === totalCells) {
                document.getElementById('overlay').classList.add('show');
                document.getElementById('winMessage').classList.add('show');
                return true;
            }

            return false;
        }


        // Startet das Spiel
        initGame();
    </script>
</body>
</html>