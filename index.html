<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jo's & Zami's  Farb-Puzzle (25 Teile) ABC</title>
    <style>
        /* Allgemeine Impressionistische Basis (UnverÃ¤ndert) */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #a8c0ff 0%, #3f2b96 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px 20px;
        }

        .header {
            color: white;
            text-align: center;
            margin-bottom: 25px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5); 
        }

        .footer {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
            background-color: lightseagreen;
            color: white;
            text-align: center;
        }

        .header h1 {
            font-size: 2.8em;
            margin-bottom: 8px;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
            align-items: flex-start; 
            flex-wrap: wrap; 
            justify-content: center;
        }

        .difficulty-selection {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 15px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .difficulty-selection label {
            margin: 0 5px;
            font-weight: 700;
            cursor: pointer;
            transition: color 0.2s;
        }

        .difficulty-selection label:hover {
            color: #ffe81d;
        }
        button, select {
            padding: 14px 28px;
            font-size: 18px;
            font-weight: 700;
            border: none;
            border-radius: 12px; 
            cursor: pointer;
            background: #ffffff;
            color: #3f2b96;
            box-shadow: 0 6px 15px rgba(0,0,0,0.2); 
            transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s;
            appearance: none; 
            -webkit-appearance: none;
            -moz-appearance: none;
            min-width: 150px;
            text-align: center;
        }
        
        select {
             /* FÃ¼gt einen kleinen Pfeil fÃ¼r das Dropdown hinzu */
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='%233f2b96' d='M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z'/%3E%3C/svg%3E");
             background-repeat: no-repeat;
             background-position: right 1rem center;
             padding-right: 3rem; 
        }

        button {
            padding: 14px 28px;
            font-size: 18px;
            font-weight: 700;
            border: none;
            border-radius: 12px; 
            cursor: pointer;
            background: #ffffff;
            color: #3f2b96;
            box-shadow: 0 6px 15px rgba(0,0,0,0.2); 
            transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s;
        }

        button:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            background: #e9ecef;
        }

        button:active {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        #correct-count {
            align-self: center; 
            font-size: 1.2em; 
            font-weight: bold; 
            color: white; 
            text-shadow: 1px 1px 2px #3f2b96; 
            padding: 5px 15px; 
            border-radius: 12px;
            background: rgba(255, 55, 255, 0.3); 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            min-width: 130px; 
            text-align: center;
        }

        .game-container {
            background: rgba(255,205,255,0.9); 
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 12px 40px rgba(0,0,0,0.4);
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
            flex-direction: row; 
        }

        /* Raster (Desktop-GrÃ¶ÃŸe) */
        .grid-container {
            display: grid;
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: var(--gap-size); 
            background: #e0e7e9;
            padding: var(--gap-size);
            border-radius: 12px;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.1);
        }

        .grid-cell {
            background: #fdfdfd;
            border: 2px dashed #aeb8c3;
            border-radius: 6px;
            position: relative;
            transition: background 0.2s;
            width: var(--cell-size); 
            height: var(--cell-size);
        }

        .grid-cell:hover {
            background: #f0f4f7;
        }

        .grid-cell.filled {
            border: 2px solid #5aa95c; 
        }
        
        /* Teile-Bereich (Desktop-Layout) */
        .pieces-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .pieces-area {
            display: grid;
            /* Passt sich an die GrÃ¶ÃŸe des Rasters an, um Platz zu sparen, falls nÃ¶tig. */
            grid-template-columns: repeat(3, var(--piece-size)); 
            gap: 10px;
            max-height: 650px; 
            overflow-y: auto;
            padding: 15px;
            background: #f7f9fb;
            border-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
        }

        .pieces-area::-webkit-scrollbar {
            width: 8px;
        }

        .pieces-area::-webkit-scrollbar-thumb {
            background-color: #a8c0ff;
            border-radius: 4px;
        }

        /* Einzelne Puzzleteile (Desktop-GrÃ¶ÃŸen) */
        .puzzle-piece {
            width: var(--piece-size);
            height: var(--piece-size);
            background: white;
            border: 4px solid #3f2b96; 
            border-radius: 8px;
            cursor: move;
            position: relative;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .puzzle-piece:hover {
            transform: scale(1.05); 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .puzzle-piece.dragging {
            opacity: 0.6;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            border: 4px dashed #3f2b96;
        }
        
        .puzzle-piece.placed {
            width: var(--cell-size-placed); 
            height: var(--cell-size-placed);
            border: 4px solid #3f2b96;
            cursor: pointer;
        }

         .puzzle-piece.invalid {
            border: 4px solid #e74c3c; 
            background: #fdeaea;
        }


        /* Dots (Desktop-GrÃ¶ÃŸe) */
        .dot {
            width: var(--dot-size); 
            height: var(--dot-size);
            border-radius: 50%;
            position: absolute;
            border: 2px solid rgba(0,0,0,0.4);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        /* Farb-Definitionen - HIER WURDE !important HINZUGEFÃœGT */
        .dot.red { background: #e74c3c !important; } 
        .dot.blue { background: #3498db !important; }
        .dot.yellow { background: #f1c40f !important; }
        .dot.green { background: #2ecc71 !important; }

        /* Dot-Positionen (Variabel) */
        .dot.top-1 { top: 5%; left: 25%; } 
        .dot.top-2 { top: 5%; right: 25%; } 
        .dot.right-1 { right: 5%; top: 25%; } 
        .dot.right-2 { right: 5%; bottom: 25%; } 
        .dot.bottom-1 { bottom: 5%; left: 25%; } 
        .dot.bottom-2 { bottom: 5%; right: 25%; } 
        .dot.left-1 { left: 5%; top: 25%; } 
        .dot.left-2 { left: 5%; bottom: 25%; } 

        /* Win Message und Overlay CSS (UnverÃ¤ndert) */
        .win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ffffff;
            padding: 50px 70px;
            border-radius: 20px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.5);
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .win-message.show {
            display: block;
            animation: popIn 0.5s ease-out;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .win-message h2 {
            color: #2ecc71;
            font-size: 3.5em;
            margin-bottom: 25px;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            z-index: 999;
        }

        .overlay.show {
            display: block;
        }

        /* ------------------------------------------------------------------ */
        /* MEDIA QUERY FÃœR SMARTPHONE-FORMAT (unter 650px Breite) (UnverÃ¤ndert) */
        /* ------------------------------------------------------------------ */
        @media (max-width: 650px) {
            
            /* GrÃ¶ÃŸere Anpassung fÃ¼r Mobile */
            :root {
                --cell-size: 60px !important;
                --cell-size-placed: 58px !important;
                --piece-size: 58px !important;
                --gap-size: 4px !important;
                --dot-size: 16px !important;
            }

            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                flex-direction: column; 
                gap: 10px;
                align-items: center;
            }

            .difficulty-selection {
                padding: 5px 10px;
            }
            
            #correct-count {
                font-size: 1em;
                padding: 5px 10px;
            }

            .game-container {
                flex-direction: column; 
                padding: 15px;
                gap: 20px;
                width: 100%;
                max-width: 400px; 
            }

            /* Pieces-Area (Mobile-Layout): Immer 4 Spalten auf Mobile */
            .pieces-area {
                gap: 4px;
                padding: 10px;
                max-height: 250px; 
                grid-template-columns: repeat(4, var(--piece-size)); 
            }
            
            /* Dots (Mobile-GrÃ¶ÃŸe) */
            .dot {
                border: 1px solid rgba(0,0,0,0.4); 
            }

            /* Dot-Positionen (Mobile) */
            .dot.top-1 { top: 2%; left: 20%; } 
            .dot.top-2 { top: 2%; right: 20%; } 
            .dot.right-1 { right: 2%; top: 20%; } 
            .dot.right-2 { right: 2%; bottom: 20%; } 
            .dot.bottom-1 { bottom: 2%; left: 20%; } 
            .dot.bottom-2 { bottom: 2%; right: 20%; } 
            .dot.left-1 { left: 2%; top: 20%; } 
            .dot.left-2 { left: 2%; bottom: 20%; } 
        }
    </style>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>ðŸŽ¨ Jo's Farb-Puzzle ABC</h1>
        <p>Ziehe die Teile ins Raster (oder verschiebe sie) und drehe sie durch Klick. Alle Kanten *mÃ¼ssen* farblich passen!</p>
        <p class="current-rule">
            Aktuelles Muster: <span id="current-rule-text">Wird geladen...</span>
        </p>
    </div>
    <div class="controls">
        <select id="pattern-selector" onchange="switchPattern(this.value)">
            <option value="symmetric">1.Leicht  .</option>
            <option value="asymmetric2" selected>2. Schwer 1  .</option>
            <option value="asymmetric3">3.Schwer 2  .</option>
            <option value="asymmetric4">4. Mittel  .</option>
        </select>
        <div class="difficulty-selection">
            <strong>Schwierigkeit:</strong>
            <div>
                <input type="radio" id="size2" name="gridSize" value="2" onchange="changeGridSize(2)" checked>
                <label for="size2">2x2</label>
                <input type="radio" id="size3" name="gridSize" value="3" onchange="changeGridSize(3)">
                <label for="size3">3x3</label>
                <input type="radio" id="size4" name="gridSize" value="4" onchange="changeGridSize(4)">
                <label for="size4">4x4</label>
                <input type="radio" id="size5" name="gridSize" value="5" onchange="changeGridSize(5)">
                <label for="size5">5x5</label>
            </div>
        </div>
        <button onclick="resetGame()">âœ¨ Neu starten</button>

        <button onclick="saveGame()">ðŸ’¾ Fortschritt speichern</button>

        <div id="correct-count">Richtig: 0 / 4</div>

    </div>

    <div class="game-container">
        <div class="grid-container" id="grid"></div>
        <div class="pieces-container">
            <h3 style="text-align: center; color: #3f2b96;">VerfÃ¼gbare Teile (25)</h3>
            <div class="pieces-area" id="pieces"></div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>

    <div class="win-message" id="winMessage">
        <h2>ðŸŽ‰ Gewonnen! ðŸŽ‰</h2>
        <p style="font-size: 1.3em; margin-bottom: 25px;">Die Farben tanzen perfekt!</p>
        <button onclick="savePuzzleImage()" style="background: #2ecc71; color: white; margin-right: 15px;">ðŸ’¾ Bild speichern</button>
        <button onclick="resetGame()">âœ¨ Nochmal spielen</button>
    </div>

    <div class="footer">
        <p> ðŸŽ¨   â’¸2025 Jo & Zami Soft  *ABC</p>
    </div>

    <script>
        const colors = ['green', 'blue', 'red', 'yellow'];
        
        // Farbcode: 0 = Rot, 1 = Blau, 2 = Gelb, 3 = GrÃ¼n

        // 1. Symmetrisches Muster: [T1, T2, R1, R2, B1, B2, L1, L2] = [A, A, B, B, C, C, D, D]
        const patternSymmetric = [
            // --- 24 Unique Permutations (4!) ---
            [0, 0, 1, 1, 2, 2, 3, 3], [0, 0, 1, 1, 3, 3, 2, 2], [0, 0, 2, 2, 1, 1, 3, 3], [0, 0, 2, 2, 3, 3, 1, 1],
            [0, 0, 3, 3, 1, 1, 2, 2], [0, 0, 3, 3, 2, 2, 1, 1], [1, 1, 0, 0, 2, 2, 3, 3], [1, 1, 0, 0, 3, 3, 2, 2],
            [1, 1, 2, 2, 0, 0, 3, 3], [1, 1, 2, 2, 3, 3, 0, 0], [1, 1, 3, 3, 0, 0, 2, 2], [1, 1, 3, 3, 2, 2, 0, 0],
            [2, 2, 0, 0, 1, 1, 3, 3], [2, 2, 0, 0, 3, 3, 1, 1], [2, 2, 1, 1, 0, 0, 3, 3], [2, 2, 1, 1, 3, 3, 0, 0],
            [2, 2, 3, 3, 0, 0, 1, 1], [2, 2, 3, 3, 1, 1, 0, 0], [3, 3, 0, 0, 1, 1, 2, 2], [3, 3, 0, 0, 2, 2, 1, 1],
            [3, 3, 1, 1, 0, 0, 2, 2], [3, 3, 1, 1, 2, 2, 0, 0], [3, 3, 2, 2, 0, 0, 1, 1], [3, 3, 2, 2, 1, 1, 0, 0],
            // 25. Teil (Duplikat von Muster 0)
            [0, 0, 1, 1, 2, 2, 3, 3] 
        ];

        // 2. Asymmetrisches Muster 2: [T1, T2, R1, R2, B1, B2, L1, L2] = [A, B, C, D, C, A, B, D]
        const patternAsymmetric2 = [
            [0, 1, 2, 3, 2, 0, 1, 3], [0, 1, 3, 2, 3, 0, 1, 2], [0, 2, 1, 3, 1, 0, 2, 3], [0, 2, 3, 1, 3, 0, 2, 1],
            [0, 3, 1, 2, 1, 0, 3, 2], [0, 3, 2, 1, 2, 0, 3, 1], [1, 0, 2, 3, 2, 1, 0, 3], [1, 0, 3, 2, 3, 1, 0, 2],
            [1, 2, 0, 3, 0, 1, 2, 3], [1, 2, 3, 0, 3, 1, 2, 0], [1, 3, 0, 2, 0, 1, 3, 2], [1, 3, 2, 0, 2, 1, 3, 0],
            [2, 0, 1, 3, 1, 2, 0, 3], [2, 0, 3, 1, 3, 2, 0, 1], [2, 1, 0, 3, 0, 2, 1, 3], [2, 1, 3, 0, 3, 2, 1, 0],
            [2, 3, 0, 1, 0, 2, 3, 1], [2, 3, 1, 0, 1, 2, 3, 0], [3, 0, 1, 2, 1, 3, 0, 2], [3, 0, 2, 1, 2, 3, 0, 1],
            [3, 1, 0, 2, 0, 3, 1, 2], [3, 1, 2, 0, 2, 3, 1, 0], [3, 2, 0, 1, 0, 3, 2, 1], [3, 2, 1, 0, 1, 3, 2, 0],
            // 25. Teil (Duplikat von Muster 0)
            [0, 1, 2, 3, 2, 0, 1, 3]  
        ];

        // 3. Asymmetrisches Muster 3: [T1, T2, R1, R2, B1, B2, L1, L2] = [A, B, C, D, A, C, D, B]
        const patternAsymmetric3 = [
            [0, 1, 2, 3, 0, 2, 3, 1], [0, 1, 3, 2, 0, 3, 2, 1], [0, 2, 1, 3, 0, 1, 3, 2], [0, 2, 3, 1, 0, 3, 1, 2],
            [0, 3, 1, 2, 0, 1, 2, 3], [0, 3, 2, 1, 0, 2, 1, 3], [1, 0, 2, 3, 1, 2, 3, 0], [1, 0, 3, 2, 1, 3, 2, 0],
            [1, 2, 0, 3, 1, 0, 3, 2], [1, 2, 3, 0, 1, 3, 0, 2], [1, 3, 0, 2, 1, 0, 2, 3], [1, 3, 2, 0, 1, 2, 0, 3],
            [2, 0, 1, 3, 2, 1, 3, 0], [2, 0, 3, 1, 2, 3, 1, 0], [2, 1, 0, 3, 2, 0, 3, 1], [2, 1, 3, 0, 2, 3, 0, 1],
            [2, 3, 0, 1, 2, 0, 1, 3], [2, 3, 1, 0, 2, 1, 0, 3], [3, 0, 1, 2, 3, 1, 2, 0], [3, 0, 2, 1, 3, 2, 1, 0],
            [3, 1, 0, 2, 3, 0, 2, 1], [3, 1, 2, 0, 3, 2, 0, 1], [3, 2, 0, 1, 3, 0, 1, 2], [3, 2, 1, 0, 3, 1, 0, 2],
            // 25. Teil (Duplikat von Muster 0)
            [0, 1, 2, 3, 0, 2, 3, 1]  
        ];

        // 4. Asymmetrisches Muster 4: [T1, T2, R1, R2, B1, B2, L1, L2] = [D, A, A, B, C, B, D, C]
        const patternAsymmetric4 = [
            [3, 0, 0, 1, 2, 1, 3, 2], [3, 0, 0, 2, 1, 2, 3, 1], [3, 1, 1, 0, 2, 0, 3, 2], [3, 1, 1, 2, 0, 2, 3, 0],
            [3, 2, 2, 0, 1, 0, 3, 1], [3, 2, 2, 1, 0, 1, 3, 0], [0, 3, 3, 1, 2, 1, 0, 2], [0, 3, 3, 2, 1, 2, 0, 1],
            [0, 1, 1, 3, 2, 3, 0, 2], [0, 2, 2, 3, 1, 3, 0, 1], [1, 0, 0, 2, 3, 2, 1, 3], [1, 0, 0, 3, 2, 3, 1, 2],
            [1, 2, 2, 0, 3, 0, 1, 3], [1, 3, 3, 0, 2, 0, 1, 2], [2, 0, 0, 1, 3, 1, 2, 3], [2, 0, 0, 3, 1, 3, 2, 1],
            [2, 1, 1, 0, 3, 0, 2, 3], [2, 3, 3, 0, 1, 0, 2, 1], [3, 0, 0, 1, 2, 1, 3, 2], [3, 1, 1, 0, 2, 0, 3, 2],
            [3, 2, 2, 0, 1, 0, 3, 1], [0, 3, 3, 1, 2, 1, 0, 2], [1, 0, 0, 2, 3, 2, 1, 3], [2, 1, 1, 0, 3, 0, 2, 3],
            // 25. Teil (Duplikat von Muster 0)
            [3, 0, 0, 1, 2, 1, 3, 2]  
        ];


        let currentPatternKey = 'asymmetric3'; 
        let allPieces = patternAsymmetric3.map((p, i) => createPiece([...p], i)); // Initialer Satz von 25 Teilen
        const MAX_PIECES = 25; // Konstante fÃ¼r die maximale Anzahl an Teilen
        
        let pieces = []; // EnthÃ¤lt immer alle 25 Teile
        let GRID_SIZE = 2; 
        let gridState = []; // GrÃ¶ÃŸe variiert je nach GRID_SIZE
        let draggedPiece = null;
        let originalGridIndex = null; 
        
        // --- Musterwechsel-Logik ---
        function switchPattern(patternKey) {
            currentPatternKey = patternKey;
            
            let newPatterns = [];
            let ruleText = "";

            if (patternKey === 'symmetric') {
                newPatterns = patternSymmetric;
                ruleText = "Symmetrisch [A, A, B, B, C, C, D, D]";
            } else if (patternKey === 'asymmetric2') {
                newPatterns = patternAsymmetric2;
                ruleText = "Asym. [A, B, C, D, C, A, B, D]";
            } else if (patternKey === 'asymmetric3') {
                newPatterns = patternAsymmetric3;
                ruleText = "Asym. [A, B, C, D, A, C, D, B]";
            } else if (patternKey === 'asymmetric4') {
                newPatterns = patternAsymmetric4;
                ruleText = "Asym. [D, A, A, B, C, B, D, C]";
            }
            
            document.getElementById('current-rule-text').textContent = ruleText;

            // Ersetze alle Teile durch die des neuen Musters
            allPieces = newPatterns.map((p, i) => createPiece([...p], i));
            
            // Starte das Spiel neu mit den neuen Teilen (inkl. Mischen)
            shufflePieces(); 
        }

        // --- Hilfsfunktionen fÃ¼r die GrÃ¶ÃŸenanpassung ---
        function setCSSVariables() {
            const root = document.documentElement;
            // Desktop-Werte --- Smartphone
            const isMobile = window.innerWidth <= 750;
            const cellSize = isMobile ? 60 : 110;

            const gapSize = 8;
            const pieceSize = 110

            // Setzen der CSS-Variablen
            root.style.setProperty('--grid-size', GRID_SIZE);
            root.style.setProperty('--cell-size', `${cellSize}px`);
            root.style.setProperty('--cell-size-placed', `${cellSize + 2}px`); 
            root.style.setProperty('--piece-size', `${pieceSize}px`);
            root.style.setProperty('--gap-size', `${gapSize}px`);
            root.style.setProperty('--dot-size', `24px`);

            // Spezielles Grid-Template fÃ¼r das Raster
            document.getElementById('grid').style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${cellSize}px)`;
        }

        function createPiece(pattern, id) {
            return {
                id: id,
                pattern: pattern,
                rotation: 0,
                placed: false,
                originalIndex: id 
            };
        }
        
        // --- Logik fÃ¼r GrÃ¶ÃŸenÃ¤nderung (behÃ¤lt die Teile und deren Rotation) ---
        function changeGridSize(newSize) {
            GRID_SIZE = newSize;
            setCSSVariables(); 

            const requiredCells = GRID_SIZE * GRID_SIZE;
            
            // Grid-Zustand neu initialisieren
            gridState = Array(requiredCells).fill(null);
            
            // Alle Teile in den verfÃ¼gbaren Pool zurÃ¼ckschicken (wichtig bei GrÃ¶ÃŸenwechsel)
            pieces.forEach(p => p.placed = false); 

            renderPieces();
            renderGrid();
            updateCorrectCount(); 
        }

        // --- Hauptlogik fÃ¼r Spielstart und -neustart (mischt alle 25 Teile neu) ---
        function shufflePieces() {

            //document.getElementById('overlay').classList.remove('show');
            //document.getElementById('winMessage').classList.remove('show');

            // --- KORRIGIERTE ANWEISUNGEN ---
            const overlay = document.getElementById('overlay');
            const winMessage = document.getElementById('winMessage');
            
            // 1. Entferne die Klasse 'show'
            overlay.classList.remove('show');
            winMessage.classList.remove('show');
            
            // 2. Setze den Display-Stil explizit auf 'none', um Inline-Styles zu Ã¼berschreiben
            overlay.style.display = 'none';
            winMessage.style.display = 'none';
            // --------------------------------
            
            setCSSVariables(); 
            const requiredCells = GRID_SIZE * GRID_SIZE;

            // 1. NEU: Erstelle eine frische Kopie ALLER 25 Teile des aktuellen Musters
            pieces = allPieces.map(p => createPiece([...p.pattern], p.id)); 
            
            // 2. Mische die Reihenfolge der 25 Teile (fÃ¼r die Darstellung im Pool)
            for (let i = pieces.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
            }

            // 3. Initialisiere die Rotation fÃ¼r alle 25 Teile
            pieces.forEach(p => {
                p.rotation = 0; 
                const numRotations = Math.floor(Math.random() * 4); 
                for (let k = 0; k < numRotations; k++) {
                    rotatePiecePattern(p); 
                }
                p.placed = false; // ZurÃ¼cksetzen
            });

            // 4. Setze GridState neu
            gridState = Array(requiredCells).fill(null);
            
            renderPieces();
            renderGrid();
            updateCorrectCount(); 
        }

        function resetGame() {
            shufflePieces();
        }

        function rotatePiecePattern(piece) {
            const p = piece.pattern;
            // Rotation um 90 Grad im Uhrzeigersinn: Top -> Right -> Bottom -> Left
            // [T1, T2, R1, R2, B1, B2, L1, L2] -> [L2, L1, T1, T2, R2, R1, B1, B2]
            piece.pattern = [p[7], p[6], p[0], p[1], p[3], p[2], p[4], p[5]];
        }

        function rotatePiece(piece) {
            rotatePiecePattern(piece);
            piece.rotation = (piece.rotation + 90) % 360;
        }

        function renderPieceElement(piece, isPlaced = false, gridIndex = null) {
            const div = document.createElement('div');
            div.className = 'puzzle-piece' + (isPlaced ? ' placed' : '');
            div.draggable = true; 
            div.dataset.id = piece.id;
            if (isPlaced) {
                 div.dataset.gridIndex = gridIndex; 
            }

            // --- NEU: GroÃŸbuchstaben-Anzeige in der Mitte ---
            const charCode = 65 + (piece.originalIndex % 26); // 65 ist 'A' in ASCII
            const pieceLabel = document.createElement('div');
            pieceLabel.textContent = String.fromCharCode(charCode);
            pieceLabel.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 1.2em; /* Macht den Buchstaben groÃŸ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
                font-weight: 900;
                color: rgba(63, 43, 150, 0.5); /* Leichte Transparenz fÃ¼r den "Impressionistischen" Stil */
                pointer-events: none; /* Wichtig, damit Klicks auf die Rotation funktionieren */
            `;
            div.appendChild(pieceLabel);
            // ---------------------------------------------------


            // Dot-Positionen: Top(1,2), Right(1,2), Bottom(1,2), Left(1,2)
            const positions = ['top-1', 'top-2', 'right-1', 'right-2', 'bottom-1', 'bottom-2', 'left-1', 'left-2'];
            piece.pattern.forEach((colorIdx, i) => {
                const dot = document.createElement('div');
                dot.className = `dot ${colors[colorIdx]} ${positions[i]}`;
                div.appendChild(dot);
            });

            // ... (restliche Event-Listener wie zuvor)
            // ...
            
            // Klick zum Rotieren
            div.addEventListener('click', (e) => {
                e.stopPropagation(); 
                rotatePiece(piece);
                if (isPlaced) {
                    renderGrid(); 
                    updateCorrectCount(); 
                    checkWin();
                } else {
                    renderPieces();
                }
            });

            // Drag-Start-Logik
            div.addEventListener('dragstart', (e) => {
                draggedPiece = piece;
                div.classList.add('dragging');
                if (isPlaced) {
                    originalGridIndex = gridIndex; 
                    e.dataTransfer.setData('text/plain', piece.id); 
                } else {
                    originalGridIndex = null; 
                }
            });

            // Drag-End-Logik
            div.addEventListener('dragend', (e) => {
                div.classList.remove('dragging');
                draggedPiece = null;
                originalGridIndex = null;
            });

            return div;
        }
      
        function renderPieces() {
            const container = document.getElementById('pieces');
            container.innerHTML = '';
            
            // Render alle 25 Teile, die nicht platziert sind
            pieces.filter(p => !p.placed).forEach(piece => {
                container.appendChild(renderPieceElement(piece));
            });
        }

        function renderGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            
            const totalCells = GRID_SIZE * GRID_SIZE;

            for (let i = 0; i < totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.index = i;

                cell.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });

                cell.addEventListener('drop', (e) => {
                    e.preventDefault();
                    
                    if (draggedPiece && !gridState[i]) {
                        
                        // Wenn das Teil von einem anderen Rasterfeld kommt, dieses Feld leeren
                        if (originalGridIndex !== null && originalGridIndex !== i) {
                            gridState[originalGridIndex] = null; 
                        }
                        
                        gridState[i] = draggedPiece;
                        draggedPiece.placed = true;
                        
                        renderPieces();
                        renderGrid();
                        updateCorrectCount(); 
                        checkWin();
                        
                    } else if (draggedPiece && gridState[i] && originalGridIndex === null) {
                         
                         // Teil aus Pool auf gefÃ¼llte Zelle fallen gelassen (Ignorieren)
                         renderGrid(); 
                         renderPieces();
                    }
                    
                    draggedPiece = null;
                    originalGridIndex = null;
                });

                if (gridState[i]) {
                    cell.classList.add('filled');
                    
                    const pieceElement = renderPieceElement(gridState[i], true, i); 
                    
                    if (!checkPieceFits(i)) {
                        pieceElement.classList.add('invalid');
                    }
                    
                    cell.appendChild(pieceElement);
                }

                grid.appendChild(cell);
            }
        }

        document.getElementById('pieces').addEventListener('dragover', (e) => e.preventDefault());
        document.getElementById('pieces').addEventListener('drop', (e) => {
            e.preventDefault();
            if (draggedPiece) {
                
                if (originalGridIndex !== null) {
                    gridState[originalGridIndex] = null; 
                }
                
                draggedPiece.placed = false; 
                
                renderPieces();
                renderGrid(); 
                updateCorrectCount(); 
            }
            draggedPiece = null;
            originalGridIndex = null;
        });

        function checkPieceFits(index) {
            const row = Math.floor(index / GRID_SIZE);
            const col = index % GRID_SIZE;
            const piece = gridState[index];
            if (!piece) return true; 

            // Kanten: 0=oben, 1=rechts, 2=unten, 3=links
            
            // Check top neighbor (row > 0)
            if (row > 0 && gridState[index - GRID_SIZE]) {
                const top = gridState[index - GRID_SIZE];
                const myTop = getEdgeColors(piece, 0);
                const theirBottom = getEdgeColors(top, 2);
                if (myTop[0] !== theirBottom[0] || myTop[1] !== theirBottom[1]) return false;
            }
            
            // Check right neighbor (col < GRID_SIZE - 1)
            if (col < GRID_SIZE - 1 && gridState[index + 1]) {
                const right = gridState[index + 1];
                const myRight = getEdgeColors(piece, 1);
                const theirLeft = getEdgeColors(right, 3);
                if (myRight[0] !== theirLeft[0] || myRight[1] !== theirLeft[1]) return false;
            }

            // Check bottom neighbor (row < GRID_SIZE - 1)
            if (row < GRID_SIZE - 1 && gridState[index + GRID_SIZE]) {
                const bottom = gridState[index + GRID_SIZE];
                const myBottom = getEdgeColors(piece, 2);
                const theirTop = getEdgeColors(bottom, 0);
                if (myBottom[0] !== theirTop[0] || myBottom[1] !== theirTop[1]) return false;
            }

            // Check left neighbor (col > 0)
            if (col > 0 && gridState[index - 1]) {
                const left = gridState[index - 1];
                const myLeft = getEdgeColors(piece, 3);
                const theirRight = getEdgeColors(left, 1);
                if (myLeft[0] !== theirRight[0] || myLeft[1] !== theirRight[1]) return false;
            }

            return true;
        }

        function updateCorrectCount() {
            let correctCount = 0;
            const totalCells = GRID_SIZE * GRID_SIZE;
            for (let i = 0; i < totalCells; i++) {
                // Ein Teil zÃ¤hlt nur als "richtig", wenn es platziert ist UND die Passform-PrÃ¼fung besteht
                if (gridState[i] && checkPieceFits(i)) {
                    correctCount++;
                }
            }
            document.getElementById('correct-count').textContent = `Richtig: ${correctCount} / ${totalCells}`;
            return correctCount; 
        }

        function getEdgeColors(piece, edge) {
            // Mapping: edge 0=oben (T1, T2), 1=rechts (R1, R2), 2=unten (B1, B2), 3=links (L1, L2)
            const indices = [
                [0, 1], [2, 3], [4, 5], [6, 7]
            ];
            return indices[edge].map(i => piece.pattern[i]);
        }

        function checkWin() {
            const totalCells = GRID_SIZE * GRID_SIZE;
            // PrÃ¼fen, ob alle Zellen belegt sind
            if (gridState.length !== totalCells || gridState.some(cell => cell === null)) return false; 
            
            const correctCount = updateCorrectCount(); 

            if (correctCount === totalCells) {
                document.getElementById('overlay').classList.add('show');
                document.getElementById('winMessage').classList.add('show');
                return true;
            }

            return false;
        }

        function savePuzzleImage() {
            const gridContainer = document.getElementById('grid'); 
            
            // TemporÃ¤r die "Richtig"-Anzeige ausblenden, falls sie Ã¼berlappt
            document.getElementById('correct-count').style.display = 'none';

            // Die winMessage temporÃ¤r ausblenden, um sie nicht im Bild zu haben
            document.getElementById('winMessage').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';


            // Verwendet html2canvas, um den Raster-Container in ein Canvas umzuwandeln
            html2canvas(gridContainer, {
                scale: 2, // ErhÃ¶ht die AuflÃ¶sung fÃ¼r ein schÃ¤rferes Bild
                backgroundColor: '#e0e7e9' // Stellt sicher, dass der Hintergrund des Rasters korrekt ist
            }).then(canvas => {
                // Erstellt einen temporÃ¤ren Link und simuliert einen Klick, um den Download auszulÃ¶sen
                const image = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                
                // FÃ¼gt den aktuellen Zeitstempel in den Dateinamen ein (Zen-Gedanke: Der Moment zÃ¤hlt)
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T-]/g, ''); 
                link.download = `Zami_Puzzle_LÃ¶sung_${timestamp}.png`;
                link.href = image;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Die ausgeblendeten Elemente wieder einblenden
                document.getElementById('correct-count').style.display = 'block';
                document.getElementById('winMessage').style.display = 'block'; 
                document.getElementById('overlay').style.display = 'block'; 
            });
        }

        function saveGame() {
            const gameState = {
                gridSize: GRID_SIZE,
                patternKey: currentPatternKey,
                // Speichere nur die platzierten Teile, ihre ID, Rotation und den Index im Raster
                gridStateData: gridState.map(piece => piece ? {
                    id: piece.id,
                    rotation: piece.rotation,
                    pattern: piece.pattern
                } : null),
                // Speichere die nicht platzierten Teile, ihre ID und Rotation
                piecesPoolData: pieces.filter(p => !p.placed).map(piece => ({
                    id: piece.id,
                    rotation: piece.rotation,
                    pattern: piece.pattern
                }))
            };
            
            // Speichern im Local Storage
            localStorage.setItem('zamiPuzzleState', JSON.stringify(gameState));
            alert("Fortschritt erfolgreich gespeichert!");
        }

        function loadGame() {
            const savedState = localStorage.getItem('zamiPuzzleState');
            if (!savedState) {
                //alert("Kein gespeicherter Fortschritt gefunden.");
                return false;
            }
            
            const gameState = JSON.parse(savedState);
            
            // 1. GrÃ¶ÃŸe und Muster wiederherstellen
            GRID_SIZE = gameState.gridSize;
            document.querySelector(`#size${GRID_SIZE}`).checked = true; // Radio-Button setzen
            
            currentPatternKey = gameState.patternKey;
            document.getElementById('pattern-selector').value = currentPatternKey; // Dropdown setzen
            
            // Da wir das Muster gewechselt haben, mÃ¼ssen wir die CSS-Variablen neu setzen
            setCSSVariables(); 

            const requiredCells = GRID_SIZE * GRID_SIZE;
            gridState = Array(requiredCells).fill(null);
            
            // Initialisiere den vollen Satz von 25 Teilen basierend auf dem geladenen Muster
            const patternMap = {
                'symmetric': patternSymmetric,
                'asymmetric2': patternAsymmetric2,
                'asymmetric3': patternAsymmetric3,
                'asymmetric4': patternAsymmetric4
            };
            
            allPieces = patternMap[currentPatternKey].map((p, i) => createPiece([...p], i));
            
            
            // 2. GridState wiederherstellen (platziert)
            gameState.gridStateData.forEach((data, index) => {
                if (data) {
                    const originalPiece = allPieces[data.id];
                    
                    // Wichtig: Wir Ã¼berschreiben das Originalteil mit den gespeicherten Werten
                    originalPiece.rotation = data.rotation;
                    originalPiece.pattern = data.pattern;
                    originalPiece.placed = true;
                    
                    gridState[index] = originalPiece;
                }
            });

            // 3. Teile-Pool wiederherstellen (nicht platziert)
            pieces = allPieces.map(p => ({ ...p })); // Kopiere alle Teile
            
            // Aktualisiere die platzierten/nicht-platzierten ZustÃ¤nde basierend auf dem Grid
            pieces.forEach(p => {
                const isPlaced = gridState.some(gp => gp && gp.id === p.id);
                p.placed = isPlaced;
            });

            // 4. Rendering und Status-Aktualisierung
            renderPieces();
            renderGrid();
            updateCorrectCount(); 
            
            //alert("Fortschritt wurde geladen!");
            return true;
        }

        function initGame(initial = true) {
            if (loadGame()) {
                // Spiel wurde geladen, nichts weiter tun
                return;
            }
            
            if (initial) {
                 // Kein gespeichertes Spiel gefunden, starte neu
                 switchPattern(document.getElementById('pattern-selector').value);
            }
        }

        initGame(true);
    </script>
</body>
</html>